## API Report File for "jood-ng-modal"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ComponentFactoryResolver } from '@angular/core';
import { ElementRef } from '@angular/core';
import * as i0 from '@angular/core';
import * as i5 from '@angular/common';
import * as i6 from '@angular/platform-browser';
import { InjectionToken } from '@angular/core';
import { Observable } from 'rxjs';
import { OnInit } from '@angular/core';
import { OpenStrategyStyleSet as OpenStrategyStyleSet_2 } from '@jood/ng-modal';
import { Properties } from 'csstype';
import { SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { Subscription } from 'rxjs';
import { ViewContainerRef } from '@angular/core';

// @public
export type EntryComponentType = any;

// @public
export class HistoryStateStrategy implements HistoryStrategy {
    // (undocumented)
    getStateOf(currentServiceId: number, state: any): {
        serviceId: any;
        before: any;
        current: any;
    };
    // (undocumented)
    getStateOfEvent(currentServiceId: number, evt: PopStateEvent): {
        serviceId: any;
        before: any;
        current: any;
    };
    // (undocumented)
    getStateOfHistory(currentServiceId: number): {
        serviceId: any;
        before: any;
        current: any;
    };
    // (undocumented)
    touch(currentServiceId: number, current: number): void;
}

// @public
export interface HistoryStrategy {
    // (undocumented)
    getStateOf(currentServiceId: number, state: any): HistoryStrategyState;
    // (undocumented)
    getStateOfEvent(currentServiceId: number, evt: PopStateEvent): HistoryStrategyState;
    // Warning: (ae-forgotten-export) The symbol "HistoryStrategyState" needs to be exported by the entry point public-api.d.ts
    //
    // (undocumented)
    getStateOfHistory(currentServiceId: number): HistoryStrategyState;
    // (undocumented)
    touch(currentServiceId: number, current: number): void;
}

// @public
export class JdModalBeforeLeaveService {
    constructor(modalService: JdModalService, modalRef: JdModalRef);
    attach(): void;
    detach(): void;
    // @internal (undocumented)
    protected fnConfirm: CastFunction<boolean>;
    // Warning: (ae-forgotten-export) The symbol "CastFunction" needs to be exported by the entry point public-api.d.ts
    //
    // @internal (undocumented)
    protected fnValidate: CastFunction<boolean>;
    // @internal (undocumented)
    protected handleBeforeLeaveIntercept: (evt: ModalPopStateEvent) => void;
    // @internal (undocumented)
    protected holdBeforeLeave: boolean;
    onBeforeLeaveConfirm(fn: CastFunction<boolean>): void;
    onBeforeLeaveValidate(fn: CastFunction<boolean>): void;
    onInterceptBeforeLeave(evt: ModalPopStateEvent): Promise<void>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalBeforeLeaveService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<JdModalBeforeLeaveService>;
}

// @public
export class JdModalComponentResolver {
    constructor(viewContainerRef: ViewContainerRef, componentFactoryResolver: ComponentFactoryResolver, modalRef: JdModalRef);
    // @internal (undocumented)
    ngOnInit(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<JdModalComponentResolver, "[jdModalComponentResolver]", never, {}, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalComponentResolver, never>;
}

// @public
export class JdModalEntryComponent {
    constructor(entryService: JdModalEntryService, refModalContainer: ElementRef<HTMLElement>);
    // (undocumented)
    get hostClass(): {
        'is-opening': boolean;
        'is-opened': boolean;
        'is-closing': boolean;
        'floating-mode': boolean;
        'full-height': boolean;
        shadow: boolean;
    };
    // (undocumented)
    get hostStyle(): Properties<0 | (string & {}), string & {}> | undefined;
    // @internal (undocumented)
    ngAfterViewInit(): void;
    // @internal (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    onOverlayClick(evt: MouseEvent): void;
    // (undocumented)
    refModalPanel: ElementRef<HTMLElement>;
    // (undocumented)
    get styles(): OpenStrategyStyleSet_2;
    // (undocumented)
    tabIndex: number;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<JdModalEntryComponent, "jd-modal-entry", never, {}, {}, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalEntryComponent, never>;
}

// @public
export class JdModalEntryResolver {
    constructor(viewContainerRef: ViewContainerRef, componentFactoryResolver: ComponentFactoryResolver);
    // (undocumented)
    modalIndex: number;
    // (undocumented)
    modalRef: JdModalRef;
    // @internal (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // @internal (undocumented)
    ngOnInit(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<JdModalEntryResolver, "[jdModalEntryResolver]", never, { "modalRef": "modalRef"; "modalIndex": "modalIndex"; }, {}, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalEntryResolver, never>;
}

// @public
export class JdModalEntryService {
    constructor(modalService: JdModalService, modalRef: JdModalRef);
    // (undocumented)
    animateTimer: any;
    // (undocumented)
    get classes(): {
        'is-opening': boolean;
        'is-opened': boolean;
        'is-closing': boolean;
        'floating-mode': boolean;
        'full-height': boolean;
        shadow: boolean;
    };
    // (undocumented)
    computedStyleSet(): void;
    // (undocumented)
    destroy(): void;
    // Warning: (ae-forgotten-export) The symbol "HandleLocationPopState" needs to be exported by the entry point public-api.d.ts
    //
    // (undocumented)
    handleLocationPopState: HandleLocationPopState;
    // (undocumented)
    historyTouched: boolean;
    // (undocumented)
    hostElement: HTMLElement;
    // (undocumented)
    isClosing: boolean;
    // (undocumented)
    isFloatingMode: boolean;
    // (undocumented)
    isFullHeight: boolean;
    // (undocumented)
    isOpened: boolean;
    // (undocumented)
    isOpening: boolean;
    // (undocumented)
    isShadow: boolean;
    // (undocumented)
    listener: Subscription;
    // (undocumented)
    mergeStyle(styleSet: any, mergeTarget: any): void;
    // (undocumented)
    modalLength: number;
    // (undocumented)
    mounted(): void;
    // (undocumented)
    mountedOpened(): void;
    // (undocumented)
    mountedOpening(): void;
    // (undocumented)
    onChangeModalState(modalState: ModalState): void;
    // (undocumented)
    onChangeOpener(evt: ModalEvent): void;
    // (undocumented)
    onLocationPopState(evt: ModalPopStateEvent): void;
    // (undocumented)
    onOverlayTouchMove(evt: TouchEvent): void;
    // (undocumented)
    overlayClick(evt: MouseEvent): void;
    // (undocumented)
    popHistoryState(): void;
    // (undocumented)
    safeTiming: number;
    // (undocumented)
    setHostElement(element: HTMLElement): void;
    // (undocumented)
    setPanelElement(element: HTMLElement): void;
    // (undocumented)
    styleSet: OpenStrategyStyleSet;
    // (undocumented)
    touchHistoryState(): void;
    // (undocumented)
    usedBlockBodyScroll: boolean;
    // (undocumented)
    usedHistoryState: boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalEntryService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<JdModalEntryService>;
}

// @public
export class JdModalModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<JdModalModule>;
    // Warning: (ae-forgotten-export) The symbol "i1" needs to be exported by the entry point public-api.d.ts
    // Warning: (ae-forgotten-export) The symbol "i2" needs to be exported by the entry point public-api.d.ts
    // Warning: (ae-forgotten-export) The symbol "i3" needs to be exported by the entry point public-api.d.ts
    // Warning: (ae-forgotten-export) The symbol "i4" needs to be exported by the entry point public-api.d.ts
    //
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<JdModalModule, [typeof i1.JdModalProviderComponent, typeof i2.JdModalEntryComponent, typeof i3.JdModalEntryResolver, typeof i4.JdModalComponentResolver], [typeof i5.CommonModule, typeof i6.BrowserModule], [typeof i1.JdModalProviderComponent]>;
}

// @public
export class JdModalProviderComponent implements OnInit {
    constructor(providerService: JdModalProviderService);
    // (undocumented)
    get hostClass(): {
        'has-modal': boolean;
        'is-emptied': boolean;
    };
    // (undocumented)
    get modalList(): JdModalRef<any, any, any>[];
    // @internal (undocumented)
    ngOnInit(): void;
    // @internal (undocumented)
    trackModalId(index: number, modal: JdModalRef): number;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<JdModalProviderComponent, "jd-modal-provider", never, {}, {}, never, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalProviderComponent, never>;
}

// @public
export class JdModalProviderService {
    constructor(modalService: JdModalService);
    // (undocumented)
    animateTimer: any;
    // (undocumented)
    get classes(): {
        'has-modal': boolean;
        'is-emptied': boolean;
    };
    // (undocumented)
    destroy(): void;
    // (undocumented)
    init(): void;
    // (undocumented)
    isEmptied: boolean;
    // (undocumented)
    listener: Subscription;
    // (undocumented)
    modalList: JdModalRef[];
    // (undocumented)
    onChangeModalState(modalState: ModalState): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalProviderService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<JdModalProviderService>;
}

// @public
export class JdModalPullDownCloseService {
    constructor(modalService: JdModalService, modalRef: JdModalRef);
    // @internal
    protected animateFrame(): void;
    changeScrollPanelElement(element: HTMLElement): void;
    // @internal
    protected clearFrame(): void;
    destroy(): void;
    dispose(): void;
    protected dragResistance: number;
    protected handleContainerTouchPrevent: (evt: TouchEvent) => void;
    protected handleTouchEnd: (evt: TouchEvent) => void;
    protected handleTouchMove: (evt: TouchEvent) => void;
    protected handleTouchMoveIntercept: (evt: TouchEvent) => void;
    protected handleTouchStart: (evt: TouchEvent) => void;
    protected holding: boolean;
    init(): void;
    protected listener: Subscription;
    protected modalPanelElement: HTMLElement;
    protected moveCheckY: number;
    protected moveIntercepCount: number;
    protected moveY: number;
    // @internal
    protected onContainerTouchPrevent(evt: TouchEvent): void;
    // @internal
    protected onTouchEnd(evt: TouchEvent): void;
    // @internal
    protected onTouchMove(evt: TouchEvent): void;
    // @internal
    protected onTouchMoveIntercept(evt: TouchEvent): void;
    // @internal
    protected onTouchStart(evt: TouchEvent): void;
    protected requestFrame: any;
    protected scrollPanelElement: HTMLElement;
    // Warning: (ae-forgotten-export) The symbol "PullDownConfig" needs to be exported by the entry point public-api.d.ts
    setConfig(config?: PullDownConfig): void;
    setScrollPanelElement(element: HTMLElement): void;
    // @internal
    protected startFrame(startX: number, startY: number): void;
    protected startStamp: number;
    protected startX: number;
    protected startY: number;
    protected triggerReleaseGap: number;
    protected triggerReleaseMinY: number;
    protected triggerReleaseMultiple: number;
    // @internal
    protected updateState(): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalPullDownCloseService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<JdModalPullDownCloseService>;
}

// @public
export class JdModalRef<R = any, D = any, C = any> {
    constructor();
    assignModalData(data: ModalData<D>): void;
    attachBeforeLeave(): void;
    // (undocumented)
    protected attachedBeforeLeave: boolean;
    close(result?: R): void;
    closed(): void;
    // (undocumented)
    protected closedSubject: Subject<R | undefined>;
    get component(): C | null;
    get data(): D | null;
    destroy(): void;
    detachBeforeLeave(): void;
    get disableShadow(): boolean;
    get duration(): number;
    get entryComponent(): any;
    get floatingMode(): boolean;
    get fullHeight(): boolean;
    get id(): number;
    get index(): number;
    get isAttachedBeforeLeave(): boolean;
    // (undocumented)
    protected modalComponent: C | null;
    // (undocumented)
    protected modalData: D | null;
    // (undocumented)
    protected modalDisableShadow: boolean;
    // (undocumented)
    protected modalEntryComponent: EntryComponentType;
    // (undocumented)
    protected modalFloatingOpenMode: boolean;
    // (undocumented)
    protected modalFullHeight: boolean;
    // (undocumented)
    protected modalId: number;
    // (undocumented)
    protected modalIndex: number;
    // (undocumented)
    protected modalOpenStrategy: OpenStrategy;
    // (undocumented)
    protected modalOverlayClose: boolean;
    // (undocumented)
    protected modalPanelElement: HTMLElement;
    // (undocumented)
    protected modalPanelStyle: any;
    // (undocumented)
    protected modalResult: R | undefined;
    // (undocumented)
    protected modalTransitionDuration: number;
    observeClosed(): Observable<R | undefined>;
    observeOpener(): Observable<ModalEvent>;
    get opener(): Subject<ModalEvent>;
    // (undocumented)
    protected openerSubject: Subject<ModalEvent>;
    get openStrategy(): OpenStrategy;
    get overlayClose(): boolean;
    get panelElement(): HTMLElement;
    get panelStyle(): any;
    setComponent(component: C): void;
    setData(data: D | undefined): void;
    setDisableShadow(is: boolean): void;
    setDuration(duration: number): void;
    setEntryComponent(entryComponent: EntryComponentType): void;
    setFloatingModel(is: boolean): void;
    setFullHeight(is: boolean): void;
    setId(id: number): void;
    setIndex(index: number): void;
    setOpenStrategy(openStrategy: OpenStrategy): void;
    setOverlayClose(is: boolean): void;
    setPanelElement(element: HTMLElement): void;
    setPanelStyle(styles: any): void;
}

// @public
export const JdModalRefToken: InjectionToken<string>;

// @public
export class JdModalService {
    protected blockBodyStyleBefore: any;
    close(id: number): void;
    closeAll(useClosing?: boolean): void;
    closeById(modalId: number): void;
    closeByRef(modalRef: JdModalRef): void;
    protected defaultEntryComponent: EntryComponentType;
    destroy(): void;
    // @internal
    protected dispatchChangeState(): void;
    getHistoryStrategy(): HistoryStrategy;
    getModalRef(id: number): JdModalRef | undefined;
    getState(): ModalState;
    hasDefaultEntryComponent(): boolean;
    get hasModal(): boolean;
    hasModalRefNext(id: number): boolean;
    protected historyStrategy: HistoryStrategy;
    get id(): number;
    init(config?: ModalConfig): void;
    isModalRefTop(modalId: number): boolean;
    protected listener: Subscription;
    protected modalRefMap: Map<number, JdModalRef>;
    get modals(): JdModalRef[];
    protected modalsSubject: Subject<ModalState>;
    protected modalUid: number;
    observeModalState(): Observable<ModalState>;
    // @internal
    protected onChangeModalState(): void;
    open<R, D = any, C = any>(data: ModalData<D, C>): JdModalRef<R, D, C>;
    pushOrder(modalRef: JdModalRef): void;
    pushOrderById(id: number): void;
    protected serviceId: number;
    setDefaultEntryComponent(entryComponent: EntryComponentType): void;
    setUseBlockBodyScroll(is: boolean): void;
    setUseHistoryState(is: boolean): void;
    swapOrder(from: number, to: number): void;
    swapOrderTopById(id: number): void;
    swapOrderTopByRef(modalRef: JdModalRef): void;
    // @internal
    protected touchBlockBodyScroll(): void;
    protected useBlockBodyScroll: boolean;
    get usedBlockBodyScroll(): boolean;
    get usedHistoryState(): boolean;
    protected useHistoryState: boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<JdModalService, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<JdModalService>;
}

// @public
export interface ModalConfig {
    // (undocumented)
    defaultEntryComponent?: EntryComponentType;
}

// @public
export interface ModalData<D = any, C = any> {
    component: C;
    data?: D;
    disableShadow?: boolean;
    duration?: number;
    entryComponent?: EntryComponentType;
    floatingMode?: boolean;
    fullHeight?: boolean;
    openStrategy?: OpenStrategy;
    overlayClose?: boolean;
    panelStyle?: any;
}

// @public
export interface ModalEvent {
    // (undocumented)
    modalRef: JdModalRef;
    // (undocumented)
    type: ModalEventType;
}

// @public
export enum ModalEventType {
    // (undocumented)
    CLOSE = 2,
    // (undocumented)
    CLOSED = 3,
    // (undocumented)
    OPEN = 0,
    // (undocumented)
    OPENED = 1
}

// @public
export interface ModalPopStateEvent extends PopStateEvent {
    _preventModalClose?: boolean;
}

// @public
export interface ModalState {
    modals: JdModalRef[];
}

// @public
export interface OpenStrategy {
    base(duration?: number): OpenStrategyStyleSet;
    closing(): OpenStrategyStyleSet;
    floatingOpening(): OpenStrategyStyleSet[];
    opened(): OpenStrategyStyleSet;
    opening(): OpenStrategyStyleSet;
    shadow(): OpenStrategyStyleSet;
}

// @public
export interface OpenStrategyStyleSet {
    // (undocumented)
    modal?: Properties;
    // (undocumented)
    overlay?: Properties;
    // (undocumented)
    pivot?: Properties;
}

// @public
export class StackBottom implements OpenStrategy {
    // (undocumented)
    base(duration?: number): {
        modal: {
            justifyContent: string;
            alignItems: string;
        };
        pivot: {
            transition: string;
            transform: string;
            borderRadius: string;
            marginTop: string;
        };
    };
    // (undocumented)
    closing(): {
        pivot: {};
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    floatingOpening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    }[];
    // (undocumented)
    opened(): {};
    // (undocumented)
    opening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    shadow(): {
        pivot: {
            filter: string;
        };
    };
}

// @public
export class StackLeft implements OpenStrategy {
    // (undocumented)
    base(duration?: number): {
        modal: {
            justifyContent: string;
            alignItems: string;
        };
        pivot: {
            transition: string;
            transform: string;
            borderRadius: string;
        };
    };
    // (undocumented)
    closing(): {
        pivot: {};
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    floatingOpening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    }[];
    // (undocumented)
    opened(): {};
    // (undocumented)
    opening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    shadow(): {
        pivot: {
            filter: string;
        };
    };
}

// @public
export class StackNormal implements OpenStrategy {
    // (undocumented)
    base(duration?: number): {
        pivot: {
            transition: string;
            transform: string;
            opacity: number;
        };
    };
    // (undocumented)
    closing(): {
        pivot: {
            transform: string;
            opacity: number;
        };
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    floatingOpening(): {
        pivot: {
            transform: string;
            opacity: number;
        };
        overlay: {
            opacity: number;
        };
    }[];
    // (undocumented)
    opened(): {};
    // (undocumented)
    opening(): {
        pivot: {
            transform: string;
            opacity: number;
        };
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    shadow(): {
        pivot: {
            filter: string;
        };
    };
}

// @public
export class StackRight implements OpenStrategy {
    // (undocumented)
    base(duration?: number): {
        modal: {
            justifyContent: string;
            alignItems: string;
        };
        pivot: {
            transition: string;
            transform: string;
            borderRadius: string;
        };
    };
    // (undocumented)
    closing(): {
        pivot: {};
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    floatingOpening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    }[];
    // (undocumented)
    opened(): {};
    // (undocumented)
    opening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    shadow(): {
        pivot: {
            filter: string;
        };
    };
}

// @public
export class StackTop implements OpenStrategy {
    // (undocumented)
    base(duration?: number): {
        modal: {
            justifyContent: string;
            alignItems: string;
        };
        pivot: {
            transition: string;
            transform: string;
            borderRadius: string;
        };
    };
    // (undocumented)
    closing(): {
        pivot: {};
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    floatingOpening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    }[];
    // (undocumented)
    opened(): {};
    // (undocumented)
    opening(): {
        pivot: {
            transform: string;
        };
        overlay: {
            opacity: number;
        };
    };
    // (undocumented)
    shadow(): {
        pivot: {
            boxShadow: string;
            filter: string;
        };
    };
}

// (No @packageDocumentation comment for this package)

```
